Java参考指南（二）

访问修饰符

对于基本的OOPS（面向对象）概念，请看Java面试参考指南的第一部分。访问修饰符规定了一个类如何访问另一个类及它的成员（包括方法和变量）。

Java中有下列访问修饰符：

private：私有变量和方法（非外部类）只能被声明它们的类的实例所使用。
default：类中的数据、方法和它本身能够被声明为默认default。类中所有default成员都可以被本包中的其它类所访问。
protected：相比default有更高的访问权限。只有成员变量和方法能够被声明为protected。父类的protected属性能被它的所有子类所共享。即使子类和父类不在同一包中，这种访问也是支持的。
public：公共的类、变量和方法都可以毫无限制的被其它Java程序所使用。
注意：

对于非内部类就只存在public访问修饰符，不存在被protected或private修饰的顶层类。
一个特性至少拥有一个访问修饰符。如果一个特性没有访问修饰符，那么它的修饰符就是default模式。
方法重载的隐私：重载后的方法修饰符不能低于被重载的方法，比如父类是protected，子类中重载方法不能置为private。
下表描述了对各个成员修饰符所运行的访问权限：

修饰符	被修饰者	描述
public	外部（Outer）类，接口，构造器，内部（Inner）类，方法和变量	可在包外部访问
protected	构造器，内部类，方法和变量	包内访问或包外的任何子类访问
private	构造器，内部类，方法和变量	只能够在它们被声明的内部访问
无描述符（default）	外部类，内部类，接口，构造器，方法和变量	只能够在它们所在包中被访问
除了上述基本的访问符之外，下表描述了Java中的其它描述符。它们能够改变类和它的成员（如：方法、变量和内部类）的行为。

 Java修饰符

修饰符	内部类/类	方法	变量
static	一个静态内部类是另一个普通类的成员，不是该类的对象成员。	一个静态方法可以直接被类访问，并且被该类的对象所共享。	静态变量是类级变量且在jvm中只能够出现一次。
abstract	抽象类不能够被实例化，它只能被其它类所继承。	抽象方法只能被声明在抽象类中，它的实现代码只能被包含在子类中。	不适用
synchronized	不适用	它在类上加了一个监视器，使得访问该方法只能通过获得该方法所属对象的锁来进行。	
transient			变量不能够被序列化。
final	类不能被继承	方法不能被重载。	变量值变成常量。
final

final修饰符只能够作用在类、方法和变量上。它的作用是所有被final修饰的内容不能被改变。如：

final类不能被继承。
final变量一旦被赋值就不能被改变。
final方法不能被重载。
注意：如果一个final变量是对象的引用，这意味着该引用的值是一定不会改变的，但是对象的成员值可以改变。

static

static修饰符可以被应用在变量、方法、代码段和内部类中。如果需要Java实例变量被存储在单独的内存中，或需要变量对一个单独类的所有对象所通用，那么静态修饰符需要被应用在该变量的声明中。

静态方法：Java的静态方法对类是通用的并且并不和Java实例相关联。尽管静态方法能够自由的访问类的静态数据和方法，但是它们并不能使用类的非静态功能。静态方法不能够被重载为非静态的。对于Java静态方法不能够使用this关键字。
静态块：静态代码块在类加载时只执行一次。
静态变量：Java的实例变量使用单独的空间进行存储。如果需要变量对一个类的所有对象都是通用的，那么这个变量就需要被声明为静态的。类的所有实例对象都可以修改该类的静态变量。此外，使用对象实例修改静态成员并不是唯一手段，也可以直接使用java类来修改。静态变量也可以被Java对象的方法所访问。当一个常量的值在编译器就已经知晓了，它就需要使用static关键字来声明为final类型。
静态内部类：只有内部类能够使用static修饰符来声明，在Java中它被称为静态嵌套类。
外部类和内部类（或者嵌套类）

在Java中，并不是所有的类都必须单独定义。你可以把一个类定义在另一个类的内部中。这个在内部定义的类就叫做内部类。包围类则被称为外部类。因此，当你定义了一个内部类，它和包围类的其它变量、方法和构造器成员一样成为该类的成员。

当你访问外部类的私有数据成员时，JDK会在外部类中创建包级访问权限的（package-acess）成员函数以便内部类来访问外部类的私有成员。这种结果会导致一个安全漏洞。通常情况下，我们应当尽量避免使用内部类。

只有当内部类仅仅只和外部类的上下文相关或者内部类需要被设置为私有的且只能被外部类访问的这些情况下，我们才使用内部类。内部类主要被用来实现类似Iterators、Comparators这些辅助类。它们被使用在外部类的上下文中。

静态嵌套类和非静态嵌套类的区别

非静态嵌套类（即内部类）对它嵌套的外部类的成员拥有全部的访问权限。而静态嵌套类并不包含对外部类的实例引用，这就使得静态嵌套类不能够调用外部类实例的非静态方法或者访问外部类的非静态字段。

在声明成员字段和方法上，非静态嵌套类不能够定义静态字段和方法。但是，静态内部类则可以定义静态字段和方法也可以定义非静态字段和方法。

非静态内部类的实例是通过使用外部类的对象引用来创建的，也就在说在内部类中已经定义了外部类实例。但是静态嵌套类实例的创建过程中并不涉及到外部类的引用，这就是说它并不拥有包围类的实例。

示例：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
public class OuterClass {
 
    class InnerClass {
        // static int x; not allowed here
    }
 
    static class StaticInnerClass {
        static int x; // allowed here
    }
}
 
class Test {
    public static void main(String... str) {
        OuterClass oc = new OuterClass();
        OuterClass.InnerClass obj1 = oc.new InnerClass();// need of inclosing
                                                            // instance
        OuterClass.StaticInnerClass obj2 = new OuterClass.SIC();
        // no need of reference of object of outer class
    }
}
native

native修饰符只能够修饰方法。native修饰符意味着方法的实现体是在JVM之外。

注意：抽象方法的实现体是在子类中，而native方法的实现体则完全不在Java的虚拟内存中，而是在其它程序库中。

transient

transient修饰符只能够应用在变量中，transient变量不做为它所属对象的持久状态的一部分进行存储。它并不需要被序列化，主要用作安全键（security key）或者连接（connection）等。

synchronized

synchronized修饰符在多线程程序中对临界区代码的访问进行控制。synchronized关键字是保持代码线程安全的工具之一。

对于某一对象的一个同步方法进行交叉访问是不可能的。当一个线程在执行某一对象的同步方法时，所有调用该同步方法的其它线程都将被阻塞直到第一个线程完成对该方法的调用。

其次，当一个同步方法执行结束时，对相同对象的后续同步方法调用，它会自动建立之前发生（happens-before）的顺序关系。这保证了该对象的状态更改对所有的线程都可见。

当你将一段代码块标记为同步化时，你需要使用对象作为该同步块的参数。当一个执行线程到达该代码块时，它首先需要等待在该对象的同步块上已经没有其它的执行线程。然而，一个线程可以进入不同对象锁定的同步方法块。

但对同一对象的非同步方法可以直接方法而无需锁检测。

如果你同步化的是静态方法，那么你同步时获取的是该方法类的锁而不是实例的。这就意味着当你同步的是静态方法时，整个类都将被阻塞。这样其它的静态同步方法也将被阻塞。

当一个线程进入同步化实例的方法时，其它线程则不能够再进入该实例的其它同步化方法。

当一个线程进入同步化的静态方法时，其它线程则不能够再进入该类的其它同步化静态方法。

注意：同步化的静态方法和同步化的非静态方法之间是没有多少联系的。例如：如果静态和非静态同步方法能够并发的执行，就需要将你的非静态方法显式的声明为在它自己的类上进行同步（如：同步MyClass.class{…}）。

volatile

只有变量能够被定义为volatile。这些变量可能会被异步修改，因此编译器需要对他们额外的关注。Volatile修饰符保证任何读取该字段的线程都能够获取它的最近修改值。

volatile使用：使用volatile的一种通用情况是将它用作boolean变量并作为判断线程终止的标志。

volatile和synchronize之间的区别：

因此，volatile关键字只用来在线程内存和主内存之间同步单个变量值，synchronized关键字用来同步线程内存和主内存之间的所有变量值以及如何锁定和释放一个监视器。清楚的是，synchronized比volatile有着更大的开销。

volatile变量不允许出现和当前主存中的数据值不同的的本地副本。

更准确地说，被声明为volatile的变量必须保证它的数据值在所有线程的中是同步的。也就是当你在任一线程中访问或者更新一个变量时，所有其它线程能够立即访问到相同的值。

abstract

abstract修饰符适用于类和方法。抽象类不能够被实例化，它必须被继承才能够访问。abstract不能够应用到类的成员变量。

示例：Animal类可以有travel方法同时它的各子类（蛇，狗，鸟）也有它们自己的travel方法。因此就不能够在超类中提供travel方法，而是需要将travel方法在超类中声明为抽象的。

注意：

如果类包含一个或多个抽象方法，编译器将强制该类必须声明为抽象的。
abstract类和final类是相对的。final类不能够被继承，而抽象类必须被继承。
设计上，你希望基类对继承类仅仅只作为接口。这意味着你不希望任何人实例化该基类。你只想进行向上类型转换（隐式转换，它能够提供多态性），这样就只能使用该基类的接口了。这是通过使用abstract关键字来修饰该类实现的。

提供限制来不实例化抽象类，这样就需要任何使用该抽象类的人来实现它。并提供多态性。

什么时候使用抽象类？

抽象类让你可以定义一些默认行为并促使子类提供任意特殊化行为。

例如：Spring的依赖注入就使得代码实现了集合框架中的接口原则和抽象实现。